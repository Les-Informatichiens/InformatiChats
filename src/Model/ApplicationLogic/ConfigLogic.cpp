//
// Created by thierrycd on 2024-01-03.
//

#include "ConfigLogic.h"

void ConfigLogic::SetupConfig()
{
    this->GenerateConfig();
    this->configAPI->LoadConfig();
    this->ApplyFilesConfig();
}

template<typename T>
std::optional<T> ConfigLogic::GetConfigValue(const std::string& key) const
{
    auto it = std::find_if(this->configSchema.entries.begin(), this->configSchema.entries.end(),
                           [&key](const ConfigEntry& entry) { return entry.GetName() == key; });

    if (it == this->configSchema.entries.end())
    {
        std::cerr << "Config entry " << key << " not found" << std::endl;
        return std::nullopt;
    }

    ConfigType val = it->GetValue();

    if (!std::holds_alternative<T>(val))
    {
        std::cerr << "Config entry " << key << " is not of type " << typeid(T).name() << std::endl;
        return std::nullopt;
    }

    return std::get<T>(val);
}

template<typename T>
void ConfigLogic::SetConfigValue(const std::string& key, const T& value) const
{
    auto it = std::find_if(this->configSchema.entries.begin(), this->configSchema.entries.end(),
                           [&key](const ConfigEntry& entry) { return entry.GetName() == key; });

    if (it == this->configSchema.entries.end())
    {
        std::cerr << "Config entry " << key << " not found" << std::endl;
        return;
    }

    ConfigType val = it->GetValue();

    if (!std::holds_alternative<T>(val))
    {
        std::cerr << "Config entry " << key << " is not of type " << typeid(T).name() << std::endl;
        return;
    }

    it->SetValue(value);
}

std::vector<ConfigEntry> ConfigLogic::GetConfigs() const
{
    return this->configSchema.entries;
}

bool ConfigLogic::IsCurrentlyEditingConfigs() const
{
    return this->currentlyEditingConfigs;
}

void ConfigLogic::SetIsCurrentlyEditingConfigs(bool currentlyEditingConfigs_)
{
    this->currentlyEditingConfigs = currentlyEditingConfigs_;
}

void ConfigLogic::GenerateConfig()
{
    this->configSchema.entries = this->configGenerator->GenerateConfig();
}

void ConfigLogic::ApplyFilesConfig()
{
    //try to set the value of each config entry generated by the config generator
    //to the value stored in the configAPI, if the values in the config API are not
    //valid, keep the generated value
    const std::unordered_map<std::string, std::string>& configs = this->configAPI->GetConfigs();

    for (ConfigEntry& entry: this->configSchema.entries)
    {
        auto it = configs.find(entry.GetName());
        if (it != configs.end())
        {
            ConfigType val;

            if(holds_alternative<int>(entry.GetValue()))
            {
                val = std::stoi(it->second);
            }
            else if(holds_alternative<double>(entry.GetValue()))
            {
                val = std::stod(it->second);
            }
            else if(holds_alternative<float>(entry.GetValue()))
            {
                val = std::stof(it->second);
            }
            else if(holds_alternative<std::string>(entry.GetValue()))
            {
                val = it->second;
            }
            else if(holds_alternative<bool>(entry.GetValue()))
            {
                if(it->second == "true")
                {
                    val = true;
                }
                else if(it->second == "false")
                {
                    val = false;
                }
                else
                {
                    std::cerr << "Config entry " << entry.GetName() << " is of type bool but has value " << it->second << std::endl;
                    continue;
                }
            }

            if (entry.Validate(val))
            {
                entry.SetValue(val);
            }
        }
    }
}

std::unordered_map<std::string, std::string> ConfigLogic::GetConfigMap() const
{
    std::unordered_map<std::string, std::string> configMap;

    for (const auto& entry: this->configSchema.entries)
    {
        configMap[entry.GetName()] = entry.ValueToString();
    }

    return configMap;
}

void ConfigLogic::SaveConfig() const
{
    this->configAPI->SetConfigs(this->GetConfigMap());
    this->configAPI->SaveConfig();
}


ConfigLogic& ConfigLogic::GetInstance()
{
    static ConfigLogic instance;
    return instance;
}
